<!DOCTYPE html>
<!--
    This page is used to verify the results of a login attempt. It securely converts
    the provided login access code into a formal accessToken. An AccessToken is the thing
    that actually grants a client access to an API. It's presented in the headers of the
    API call. See the POC README for more detail.

    See the JS code and the POC README for more information.

    Note that it's possible to combine the login.html and authorize.html pages into a single
    HTML page. However, doing so would make the process more opaque, so I've separated them
    out for the POC.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Authorize</title>
    <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">

    <script>
        // TODO: these values need to be parameterised in the application.
        const clientID = "205769478103975430@bookwork"
        const redirectURI = "https://hello.bookwork.com/login/authorize.html"
        const tokenURL = "https://hello.bookwork.com/oauth/v2/token"

        // Obtain the access token from the server.
        async function getAccessToken() {
            const url = new URL(window.location)
            const params = url.searchParams

            // The code parameter is generated by Zitadel as a redirect. Because it's in the
            // URL, it's possible for it to be eavesdropped via MITM, OS and other attacks. So,
            // as the receiver, we need to verify to Zitadel that we are authorised to have the code.
            // And to do that, we use the random code challenge which was generated in the original
            // request. This ensures that only the browser that requested the access code can
            // convert it into an accessToken. This process is called "PKCE".
            // More info and a link to the RFC here:
            // https://zitadel.com/docs/guides/integrate/oauth-recommended-flows#our-recommended-authorization-flows
            const code = params.get("code")

            // This is the code challenge we generated. Until this point, only we know the challenge, because
            // it was only sent as a hash during the code request. We are now going to send
            // it in the clear, to prove that we are the party who initiated the login flow.
            // Note: once we use the code, it can't be reused.
            let challengeString = sessionStorage.getItem("bookworkCodeVerifier")
            sessionStorage.removeItem("bookworkCodeVerifier")

            // Now we put together and send a form to request the accessToken.
            const formData = new FormData();

            formData.append("grant_type", "authorization_code");
            formData.append("code", code)
            formData.append("redirect_uri", redirectURI)
            formData.append("client_id", clientID)
            formData.append("code_verifier", challengeString)

            const tokenResult = await fetch(tokenURL, {
                method: "POST",
                body: formData
            })

            // Wait for the resulting token.
            // TODO: should redirect to the login page if there's an error.
            const tokenObject = await tokenResult.json()

            // Extract the access token and store it in session storage.
            // The access token will be used during API calls to prove that we are
            // who we say we are.
            const accessToken = tokenObject.access_token
            sessionStorage.setItem("bookworkAccessToken", accessToken);

            // Redirect to the actual application.
            window.location = "/home.html"
        }
    </script>
</head>
<body>

<h1>Logging you in...</h1>

<script>getAccessToken()</script>

</body>
</html>